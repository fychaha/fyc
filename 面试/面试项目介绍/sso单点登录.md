jwt原理：jwt分三部分，头部，荷载，签名。

头部：加密算法

荷载：签发人，到期时间，签发时间，唯一标识（UUID）

签名部分：首先用base64算法对头部和荷载分别加密并用"."连接，然后用头部内的加密算法（HS256）对得出的密文再次加密，最后再次用base64加密，如此三次加密得到签名。

说一下单点登录

在我们负责的模块，分两块认证，一是对jwtToken合法性进行验证，二是对登录用户的权限进行认证。

用户登录时，在数据库查询该用户所有拥有的角色和权限，并将这些信息存放在map里返回，同时生成jwtToken，会将这些用户信息放入jwtoken，然后将token存到redis里。

用户发起请求，请求进入网关，然后被shiro的AccessContollerFilter拦截器所拦截，然后调用verity()判断当前请求是否携带jwtToken, 在redis里查询这个用户账号为key，是否有值，没有就表示用户可能登出或者未登陆。

如果携带就委托jwtRealm验证jwtToken的合法性，如果合法，就表示我这个请求的用户是登录过的。

具体验证逻辑：我们封装了一个JwtUtil工具类，里面有encode()方法，传入用户信息，签发人以及有效期实现生成jwtToken。decode()方法则是反向操作，解密jwtToken拿到放在里面的用户信息。还有个验证jwt有效性的方法isVerify()。 

shiro过滤器处理完后，请求转发前进入zuul网关的过滤器，在开关部分拿到jwtToken，因为是restful风格的请求，通过token里该用户的权限，与请求路径的权限路径做匹配，如果匹配上，说明权限足够，就返回false，跳过网关过滤器的run方法，不然就返回true在run方法内向前台返回响应表示权限不够。









