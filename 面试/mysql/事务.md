### 说说你对事务的理解

事务有4大特性：

1. 原子性：每条事务都是一个原子操作，事务内包含的sql操作要么全部成功，要么全部失败。
2. 一致性：无论在事务执行前还是执行后，数据始终保持完整，保持状态。
3. 隔离性：并发访问数据库时，事务彼此之间互不干扰。
4. 持久性：一个事务提交后，他对数据库的改变是永久性的。

### 并发事务可能带来什么问题？

现实中多个用户同时对数据库进行访问操作这是必然发生的，同时也会导致以下问题。

- 脏读：当事务a与事务b同时访问数据库，a对数据进行了修改，但尚未提交，这时b读取这个数据，因为这是个还没提交的数据，所以b读取的是个脏数据，拿着脏数据做操作，那么接下来的操作就有可能是错误的（如果a最终提交事务就没好，若是a回滚了事务，那b的操作必定是会出问题的）。
- 丢失修改：a修改了数据，还没提交，此时b又修改了数据，那么谁先提交谁的修改操作就会丢失。如m=20，事务a执行m--，还没提交，此时b读取到m=20，执行m++,然后a提交m=19，接着b提交m=21，最终数据库m的值为21，a的操作白干了。
- 不可重复读：事务a内有两次读操作，a第一次读取数据，随后事务b对该数据进行了修改，改完后提交，此时事务a慢悠悠地做完其他操作，进行第二次读，a发现该数据第一次读和第二次读的结果是不一样的。
- 幻读：原理和不可重复读一样，只不过幻读的重点在于数据的增删，导致读到不存在的数据或者本应不存在的数据。而不可重复读的重点在于修改。

### 怎么解决以上问题？

sql标准定义了4个事务隔离级别：

- 读取未提交：

  最低级别，允许读取尚未提交的数据。

- 读取已提交：

  允许读取并发事务已经提交的事务，仅阻止了脏读

- 可重复读：（InnoDB引擎默认）

  对同一字段的多次读取结果一致，除非是事务自己修改的，可以阻止脏读和不可重复度，但幻读仍有可能发生。

- 可串行化：

  最高隔离级别，完全服从acid的隔离级别，所有事务依次逐条执行，一条一条地执行。