#### 垃圾回收的发生区域

​	在java虚拟机划分的内存中，程序计数器虚拟机栈，本地方法栈3个区域随线程而生，随线程而灭，方法或者线程结束，那么这里的内存也自动释放。

​	而java堆和方法区则不一样，，一个接口中的多个实现类需要的内存不一样，一个方法中的多个分支需要的内存也可能不一样，只有在程序处于运行期间时才可能知道会创建哪些对象。这里就是垃圾回收的重点区域。

## 如何判断对象已死？

​	垃圾回收就是把那些不可能在被任何途径使用的对象从内存中释放掉。，那如何判断对象是死是活呢？

#### 引用计数算法（非jvm采用）

​	这里介绍一下引用计数算法：给对象添加一条引用计数器，每当有一个地方引用他时，计数器就加1；当引用失效时，计数器就减1.任何时刻计数器值为0的对象就是不可能再被使用的。

​	这种算法实现既简单，判定效率也很高。在Python的内存管理中就用到了这种算法。但是子jvm中并没有采用这种算法，主要原因是它难以解决对象之间互相循环引用的问题。

​	举个例子

```java
public class GcTest{
    public Object instance =null;
    public static void test(){
        GcTest obj1=new GcTest();
        GcTest obj2=new GcTest();
        obj1.instance=obj2;
        obj2.instance=obj1;
        obj1=null;
        obj2=null；
        //假设在这行发生垃圾回收
        System.gc();
    }
}
```

这里两个对象互相引用，引用计数算法是不能判断他们是否已死的，但是java能把他们回收掉，说明jvm并不是用引用计数算法的。

### 可达性分析算法

在java，c#中，都是通过可达性分析来判断对象是否存活。

算法基本思路：通过一系列的称为“GC Roots”的对象作为起始点，从这些节点出发开始向下搜索，搜索所走过的路径称为引用链，当一个对象到“GC Roots”没有任何引用链相连时，就证明这个对象是不可用的。

![img](http://www.coderymy.cn/images/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E6%B3%95.png)

在java中，可作为GC Roots的对象包括以下几种：

1. 虚拟机栈中引用的对象
2. 方法区中类静态属性引用的对象。
3. 方法区常量引用额对象。
4. 本地方法栈中JNI（Native方法）引用的对象。



jdk1.2就增加了上述的使用方法，提出了四个引用形式

> 强引用：只要强引用还存在，那么垃圾回收器就永远不会回收掉这中引用对应的对象
>
> 如 Object obj = new Object()
>
> 软引用：用来描述一些还有用，但并非必须的对象。这种对象会在内存溢出异常之前，也就是第二次回收的时候被回收掉。jdk1.2之后使用`SoftReference`类创建
>
> 弱引用：描述非必须的对象，这种对象会直接被下一次的垃圾回收回收掉。也就是说无论内存是否足够都会被回收。jdk1.2之后使用`WeakReference`类创建
>
> 虚引用：这是一种比较特殊的存在，他的目的是**能在这个对象被收集器回收的时候收到一个系统通知**。jdk1.2之后使用`PhantomReference`类创建

我们一般创建的引用都是强引用。所以也就是说，只有这个引用不存在的时候才会被回收